#include <windows.h>
#include <stdio.h>
#include <wincrypt.h>
#include <time.h>
#include "sqlite3.h"

#define SHA256_HASH_SIZE 32
#define BUFSIZE 1024
#define SHA256LEN 32
#define SHA256_HASH_STRING_LEN 64

int create_virus_signature_table(sqlite3 *db, const char *table_name)
{
    char sql[128];
    snprintf(sql, sizeof(sql),
             "CREATE TABLE IF NOT EXISTS %s ("
             "sha256_hash TEXT NOT NULL UNIQUE);",
             table_name);

    if (sqlite3_exec(db, sql, NULL, NULL, NULL) != SQLITE_OK)
    {
        fprintf(stderr, "Error creating table: %s\n", sqlite3_errmsg(db));
        return -1;
    }
    printf("Table '%s' created successfully.\n", table_name);
    return 0;
}

int main(){
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);
    WIN32_FIND_DATAA findFileData; // Sử dụng WIN32_FIND_DATAA cho ANSI (char*)
    HANDLE hFind = INVALID_HANDLE_VALUE;
    char searchPath[MAX_PATH];
    const char *targetDirectory = "C:\\Users\\BRUH\\Desktop\\Virus"; // Lưu đường dẫn gốc vào một biến
    sqlite3 *db; // Con trỏ đến đối tượng database
    char *zErrMsg = 0; // Con trỏ để lưu thông báo lỗi từ SQLite
    int rc; // Mã trả về của các hàm SQLite

    rc = sqlite3_open("temp.db", &db);

    char type[256];

    printf("Enter malware type: ");
    scanf("%s", type);

    create_virus_signature_table(db, type);

    // Xây dựng đường dẫn tìm kiếm (ví dụ: "C:\\Folder\\*.*")
    // Đảm bảo có đủ không gian cho đường dẫn + "\\*.*" + null terminator
    _snprintf_s(searchPath, sizeof(searchPath), _TRUNCATE, "%s\\*.*", targetDirectory);

    // Bắt đầu tìm kiếm file đầu tiên
    hFind = FindFirstFileA(searchPath, &findFileData); // Sử dụng FindFirstFileA cho ANSI
    if (hFind == INVALID_HANDLE_VALUE) {
        return -1;
    }
    do {

        if (strcmp(findFileData.cFileName, ".") == 0 || strcmp(findFileData.cFileName, "..") == 0) {
            continue; // Chuyển sang lần lặp tiếp theo
        }

        char fullFilePath[MAX_PATH]; // Buffer để lưu đường dẫn đầy đủ đến file
        char hash_str[SHA256_HASH_STRING_LEN + 1]; // +1 cho null terminator
        memset(hash_str, 0, sizeof(hash_str));
            
        // Xây dựng đường dẫn đầy đủ: targetDirectory + "\\" + findFileData.cFileName
        _snprintf_s(fullFilePath, sizeof(fullFilePath), _TRUNCATE, "%s\\%s", targetDirectory, findFileData.cFileName);

        FILE *file = fopen(fullFilePath, "rb"); // Mở file với đường dẫn đầy đủ

        HCRYPTPROV hProv = 0;
        HCRYPTHASH hHash = 0;
        BYTE buffer[BUFSIZE];
        DWORD bytesRead;
        BYTE hash_binary[SHA256_HASH_SIZE];
        DWORD hashLen = SHA256LEN;

        if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
            fclose(file);
            return 1;
        }

        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {
            CryptReleaseContext(hProv, 0);
            fclose(file);
            return 1;
        }

        while ((bytesRead = fread(buffer, 1, BUFSIZE, file)) != 0) {
            if (!CryptHashData(hHash, buffer, bytesRead, 0)) {
                CryptDestroyHash(hHash);
                CryptReleaseContext(hProv, 0);
                fclose(file);
                return 1;
            }
        }

        if (CryptGetHashParam(hHash, HP_HASHVAL, hash_binary, &hashLen, 0)) {
            for (DWORD i = 0; i < hashLen; i++) {
                sprintf(&hash_str[i * 2], "%02x", hash_binary[i]);
            }
            hash_str[SHA256_HASH_STRING_LEN * 2] = '\0';
        } else {

        }

        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        fclose(file);

        sqlite3_stmt *stmt; // Con trỏ đến prepared statement
        char sql_insert[256];
        snprintf(sql_insert, sizeof(sql_insert), "INSERT INTO %s (sha256_hash) VALUES (?);", type);

        // 1. Chuẩn bị câu lệnh SQL
        // sqlite3_prepare_v2 biên dịch câu lệnh SQL thành một prepared statement.
        // Tham số cuối cùng (&tail) thường là NULL nếu toàn bộ câu lệnh được sử dụng.
        rc = sqlite3_prepare_v2(db, sql_insert, -1, &stmt, NULL);
        if (rc != SQLITE_OK) {
            fprintf(stderr, "Lỗi khi chuẩn bị câu lệnh INSERT: %s\n", sqlite3_errmsg(db));
            return rc;
        }

        // 2. Gắn các giá trị vào placeholder (?)
        // Placeholder được đánh số từ 1.
        // sqlite3_bind_text: Gắn một giá trị chuỗi (text) vào placeholder.
        // Tham số 1: prepared statement
        // Tham số 2: Vị trí placeholder (bắt đầu từ 1)
        // Tham số 3: Giá trị chuỗi
        // Tham số 4: Độ dài chuỗi (-1 để tự động tính độ dài đến ký tự null)
        // Tham số 5: Destructor cho chuỗi. SQLITE_STATIC nghĩa là SQLite không giải phóng chuỗi này.
            
        // Gắn sha256_hash vào placeholder thứ nhất
        rc = sqlite3_bind_text(stmt, 1, hash_str, -1, SQLITE_STATIC);
        if (rc != SQLITE_OK) {
            fprintf(stderr, "Lỗi khi gắn sha256_hash: %s\n", sqlite3_errmsg(db));
            sqlite3_finalize(stmt); // Đảm bảo giải phóng statement nếu có lỗi
            return rc;
        }

        // 3. Thực thi câu lệnh
        // sqlite3_step thực thi câu lệnh đã được chuẩn bị.
        // Đối với INSERT, UPDATE, DELETE, nó sẽ trả về SQLITE_DONE khi thành công.
        // Đối với SELECT, nó sẽ trả về SQLITE_ROW cho mỗi hàng kết quả.
        rc = sqlite3_step(stmt);

        // 4. Giải phóng prepared statement
        // Luôn gọi sqlite3_finalize để giải phóng tài nguyên sau khi sử dụng statement.
        sqlite3_finalize(stmt);

        
    } while (FindNextFileA(hFind, &findFileData) != 0); // Tiếp tục tìm các file tiếp theo

    // Xử lý lỗi nếu có (khác ERROR_NO_MORE_FILES)
    DWORD dwError = GetLastError();
    if (dwError != ERROR_NO_MORE_FILES) {
        fprintf(stderr, "Lỗi khi duyệt thư mục: %lu\n", dwError);
        FindClose(hFind);
        return -1;
    }

    FindClose(hFind); // Đóng handle tìm kiếm
    sqlite3_close(db);
    return 0;
}